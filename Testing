
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.lang.reflect.Field;
import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class TmlInternalApsServiceImplTest {

    private TmlInternalApsServiceImpl service;

    @Before
    public void setup() throws Exception {
        service = new TmlInternalApsServiceImpl();

        // Inject cache and allocCache using reflection
        setPrivateField(service, "cache", new HashSet<>(Collections.singleton("CACHED_TRACE")));
        setPrivateField(service, "allocCache", new HashSet<>(Collections.singleton("ALLOC_CACHED_TRACE")));
    }

    @Test
    public void testGetTrnf1_AllBranchesCovered() throws Exception {
        // Create mocked allocation with ALLOCATION_PROCESS type
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getAllocationType()).thenReturn(AllocationType.ALLOCATION_PROCESS);

        // 1st: trace in cache → skipped
        Gmitrnfl t1 = mock(Gmitrnfl.class);
        when(t1.getFtrace()).thenReturn("CACHED_TRACE");

        // 2nd: trace in allocCache and ALLOCATION_PROCESS → skipped
        Gmitrnfl t2 = mock(Gmitrnfl.class);
        when(t2.getFtrace()).thenReturn("ALLOC_CACHED_TRACE");

        // 3rd: isAvgOrClosedFill = true → skipped
        Gmitrnfl t3 = mock(Gmitrnfl.class);
        when(t3.getFtrace()).thenReturn("TRACE_CLOSED");
        when(t3.getFstat7()).thenReturn("X");
        mockStaticHexToBinary("TRACE_CLOSED", true);  // should be skipped

        // 4th: valid trade → should return this one
        Gmitrnfl t4 = mock(Gmitrnfl.class);
        when(t4.getFtrace()).thenReturn("VALID_TRACE");
        when(t4.getFstat7()).thenReturn("O");
        mockStaticHexToBinary("VALID_TRACE", false);  // should pass

        List<Gmitrnfl> trnList = Arrays.asList(t1, t2, t3, t4);

        Gmitrnfl result = service.getTrnf1(trnList, alloc);
        assertNotNull(result);
        assertEquals("VALID_TRACE", result.getFtrace());
    }

    // Helper to inject private fields
    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    // Mock static method HexToBinaryConverter.isAvgOrClosedFill(String)
    private void mockStaticHexToBinary(String fstat7, boolean returnValue) {
        Mockito.mockStatic(HexToBinaryConverter.class)
               .when(() -> HexToBinaryConverter.isAvgOrClosedFill(fstat7))
               .thenReturn(returnValue);
    }
}





@RunWith(MockitoJUnitRunner.class)
public class TmlInternalApsServiceImplTest {

    private TmlInternalApsServiceImpl service;

    @Before
    public void setUp() {
        service = new TmlInternalApsServiceImpl();
    }

    @Test
    public void testGetGmiParams() throws Exception {
        // Setup
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getExecBrkMneC()).thenReturn("EXFIRM");
        when(alloc.getGmiExchCdC()).thenReturn("27");
        when(alloc.getGmiContractCdC()).thenReturn("FCODE");
        when(alloc.getQuantityI()).thenReturn(10);
        when(alloc.getSideC()).thenReturn("BUY");
        when(alloc.getPriceD()).thenReturn(new BigDecimal("123.45"));
        when(alloc.getStrikePriceD()).thenReturn(new BigDecimal("150.00"));
        when(alloc.getPutCallC()).thenReturn("C");

        Date tradeDate = new SimpleDateFormat("yyyy-MM-dd").parse("2024-12-15");
        Date maturityDate = new SimpleDateFormat("yyyy-MM-dd").parse("2025-06-15");

        when(alloc.getTradeDateDt()).thenReturn(tradeDate);
        when(alloc.getMaturityDateDt()).thenReturn(maturityDate);

        List<String> accounts = Arrays.asList("ACCT001");
        List<String> ftracel = Arrays.asList("TRACE001");
        List<String> execFirmL = null;

        // Use reflection to call protected method
        Method method = TmlInternalApsServiceImpl.class.getDeclaredMethod("getGmiParams",
                TAllocationGenericId.class, List.class, List.class, List.class);
        method.setAccessible(true);

        @SuppressWarnings("unchecked")
        Map<String, Object> result = (Map<String, Object>) method.invoke(service, alloc, accounts, ftracel, execFirmL);

        // Validate result
        assertNotNull(result);
        assertEquals("FCODE", result.get("FFC"));
        assertEquals(accounts, result.get("ACCOUNT"));
        assertEquals(10, result.get("FQTY"));
        assertEquals("27", result.get("FEXCH"));
        assertEquals("1", result.get("FBS")); // from BUY => 1
        assertEquals(123.45, result.get("FTPRIC"));
        assertEquals("C", result.get("FSUBTY"));
        assertEquals(150.00, result.get("FSTRIK"));
        assertTrue(((List<?>) result.get("FIEFRM")).contains("EXFIRM"));
        assertEquals(ftracel, result.get("MSG_FTRACE"));

        // Optional: print out keys for debug
        result.forEach((k, v) -> System.out.println(k + " = " + v));
    }
}






@RunWith(MockitoJUnitRunner.class)
public class TmlInternalApsServiceImplTest {

    @InjectMocks
    private TmlInternalApsServiceImpl service;

    @Mock
    private TmlQueryDao tmlQueryDao;

    @Spy
    private Logger log = LoggerFactory.getLogger(TmlInternalApsServiceImpl.class);

    @Before
    public void setup() throws Exception {
        // Inject mock logger if necessary via reflection
        Field logField = TmlInternalApsServiceImpl.class.getDeclaredField("log");
        logField.setAccessible(true);
        logField.set(service, log);
    }

    @Test
    public void testProcessReplayGroup_withOnlyAvg() {
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(true);
        when(container.hasSamePriceQty(Mockito.anyInt())).thenReturn(true);

        Map<String, AllocContainer> allocMap = new HashMap<>();
        allocMap.put("group1", container);

        // Mock getAllocs() via reflection
        try {
            Method setAllocMethod = TmlInternalApsServiceImpl.class.getDeclaredMethod("getAllocs", String.class);
            setAllocMethod.setAccessible(true);
        } catch (Exception e) {
            fail("Reflection error in setting up getAllocs()");
        }

        // Force override getAllocs to return mock data
        doReturn(allocMap).when(service).getAllocs(Mockito.anyString());

        // Run
        service.processReplayGroup();

        // Verify log and logic
        verify(log, atLeastOnce()).info(contains("Started (processReplayGroup) processing group:"));
        verify(container, times(1)).hasOnlyAvg();
        verify(container, never()).hasSamePriceQty(Mockito.anyInt());
    }

    @Test
    public void testProcessReplayGroup_withSamePriceQty() {
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(false);
        when(container.hasSamePriceQty(Mockito.anyInt())).thenReturn(true);

        Map<String, AllocContainer> allocMap = new HashMap<>();
        allocMap.put("group2", container);

        doReturn(allocMap).when(service).getAllocs(Mockito.anyString());

        service = Mockito.spy(service); // so we can verify internal method
        doNothing().when(service).updateMatchedStatus(anyString(), anyString(), any(AllocContainer.class));

        service.processReplayGroup();

        verify(service).updateMatchedStatus(eq("RTS"), contains("fills and avg lines found"), eq(container));
    }

    @Test
    public void testProcessReplayGroup_withException() {
        doThrow(new RuntimeException("Test Exception")).when(service).getAllocs(anyString());

        service.processReplayGroup(); // should catch internally

        verify(log).error(contains("exception occured while processing processReplayGroup"), any(Exception.class));
    }
}
