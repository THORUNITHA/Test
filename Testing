 @RunWith(MockitoJUnitRunner.class)
public class TmlInternalApsServiceImplTest {

    private TmlInternalApsServiceImpl service;

    @Before
    public void setUp() {
        service = new TmlInternalApsServiceImpl();
    }

    @Test
    public void testGetGmiParams() throws Exception {
        // Setup
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getExecBrkMneC()).thenReturn("EXFIRM");
        when(alloc.getGmiExchCdC()).thenReturn("27");
        when(alloc.getGmiContractCdC()).thenReturn("FCODE");
        when(alloc.getQuantityI()).thenReturn(10);
        when(alloc.getSideC()).thenReturn("BUY");
        when(alloc.getPriceD()).thenReturn(new BigDecimal("123.45"));
        when(alloc.getStrikePriceD()).thenReturn(new BigDecimal("150.00"));
        when(alloc.getPutCallC()).thenReturn("C");

        Date tradeDate = new SimpleDateFormat("yyyy-MM-dd").parse("2024-12-15");
        Date maturityDate = new SimpleDateFormat("yyyy-MM-dd").parse("2025-06-15");

        when(alloc.getTradeDateDt()).thenReturn(tradeDate);
        when(alloc.getMaturityDateDt()).thenReturn(maturityDate);

        List<String> accounts = Arrays.asList("ACCT001");
        List<String> ftracel = Arrays.asList("TRACE001");
        List<String> execFirmL = null;

        // Use reflection to call protected method
        Method method = TmlInternalApsServiceImpl.class.getDeclaredMethod("getGmiParams",
                TAllocationGenericId.class, List.class, List.class, List.class);
        method.setAccessible(true);

        @SuppressWarnings("unchecked")
        Map<String, Object> result = (Map<String, Object>) method.invoke(service, alloc, accounts, ftracel, execFirmL);

        // Validate result
        assertNotNull(result);
        assertEquals("FCODE", result.get("FFC"));
        assertEquals(accounts, result.get("ACCOUNT"));
        assertEquals(10, result.get("FQTY"));
        assertEquals("27", result.get("FEXCH"));
        assertEquals("1", result.get("FBS")); // from BUY => 1
        assertEquals(123.45, result.get("FTPRIC"));
        assertEquals("C", result.get("FSUBTY"));
        assertEquals(150.00, result.get("FSTRIK"));
        assertTrue(((List<?>) result.get("FIEFRM")).contains("EXFIRM"));
        assertEquals(ftracel, result.get("MSG_FTRACE"));

        // Optional: print out keys for debug
        result.forEach((k, v) -> System.out.println(k + " = " + v));
    }
}






@RunWith(MockitoJUnitRunner.class)
public class TmlInternalApsServiceImplTest {

    @InjectMocks
    private TmlInternalApsServiceImpl service;

    @Mock
    private TmlQueryDao tmlQueryDao;

    @Spy
    private Logger log = LoggerFactory.getLogger(TmlInternalApsServiceImpl.class);

    @Before
    public void setup() throws Exception {
        // Inject mock logger if necessary via reflection
        Field logField = TmlInternalApsServiceImpl.class.getDeclaredField("log");
        logField.setAccessible(true);
        logField.set(service, log);
    }

    @Test
    public void testProcessReplayGroup_withOnlyAvg() {
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(true);
        when(container.hasSamePriceQty(Mockito.anyInt())).thenReturn(true);

        Map<String, AllocContainer> allocMap = new HashMap<>();
        allocMap.put("group1", container);

        // Mock getAllocs() via reflection
        try {
            Method setAllocMethod = TmlInternalApsServiceImpl.class.getDeclaredMethod("getAllocs", String.class);
            setAllocMethod.setAccessible(true);
        } catch (Exception e) {
            fail("Reflection error in setting up getAllocs()");
        }

        // Force override getAllocs to return mock data
        doReturn(allocMap).when(service).getAllocs(Mockito.anyString());

        // Run
        service.processReplayGroup();

        // Verify log and logic
        verify(log, atLeastOnce()).info(contains("Started (processReplayGroup) processing group:"));
        verify(container, times(1)).hasOnlyAvg();
        verify(container, never()).hasSamePriceQty(Mockito.anyInt());
    }

    @Test
    public void testProcessReplayGroup_withSamePriceQty() {
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(false);
        when(container.hasSamePriceQty(Mockito.anyInt())).thenReturn(true);

        Map<String, AllocContainer> allocMap = new HashMap<>();
        allocMap.put("group2", container);

        doReturn(allocMap).when(service).getAllocs(Mockito.anyString());

        service = Mockito.spy(service); // so we can verify internal method
        doNothing().when(service).updateMatchedStatus(anyString(), anyString(), any(AllocContainer.class));

        service.processReplayGroup();

        verify(service).updateMatchedStatus(eq("RTS"), contains("fills and avg lines found"), eq(container));
    }

    @Test
    public void testProcessReplayGroup_withException() {
        doThrow(new RuntimeException("Test Exception")).when(service).getAllocs(anyString());

        service.processReplayGroup(); // should catch internally

        verify(log).error(contains("exception occured while processing processReplayGroup"), any(Exception.class));
    }
}
